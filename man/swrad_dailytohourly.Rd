% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/temporaldownscale.R
\name{swrad_dailytohourly}
\alias{swrad_dailytohourly}
\title{Daily to hourly shortwave radiation}
\usage{
swrad_dailytohourly(radsw, tme = NA, r = NA, clearsky = NA, adjust = TRUE)
}
\arguments{
\item{radsw}{\itemize{
\item an array of daily mean radiation values (W/m**2)
}}

\item{tme}{\itemize{
\item POSIXlt object of dates corresponding to radsw
}}

\item{r}{\itemize{
\item if radsw is a spatraster r=NA
- if radsw is an array, r is a terra::SpatRaster object giving the extent of radsw
- if radsw is a vector of c(lat,lon) of the location radsw describes
}}

\item{clearsky}{\itemize{
\item optionally an array with dimensions matching radsw of daily clearsky
radiation as returned by clearskyraddaily(). Calculated if not supplied
}}

\item{adjust}{\itemize{
\item optional logical which if TRUE ensures that, after interpolation, returned
hourly values, when averaged to daily, match the input
}}
}
\value{
an array of hourly radiation values (W/m**2)
}
\description{
Derives an array of hourly radiation values from an array of daily radiation values.
}
\details{
NB - this assumes input radiation is downward flux, not net radiation (as assumed in UKCP)
to get from net to downward flux we need to recognise that rswnet = (1-alb)*radsw, so
radsw = rswnet/(1-alb), where alb is white sky albedo. White-sky albedo changes as a function
of solar angle, but in a manner dependent on ground reflectance, leaf area, leaf inclination
angles and leaf transmittance and the ratio of diffuse and direct. There are too
many vegetation parameter unknowns to reverse engineer, so suggest ignoring this.
discrepancies probably quite minor expect in areas with very low cover and will be handled
mostly by bias correction anyway
~~ * Need to spline interpolate clear-sky fraction (bounding by 1 and 0) and
~~   then calculate clear-sky radiation
~~ * Need to spline interpolate sky emissvity (bounding by 1 and 0) and
~~   then calculate longwave
}
\examples{
# ========================================================================= #
# ~~~~~~~~~~~~~~~~~~~~ input provided as SpatRaster ======================= #
# ========================================================================= #
climdaily<- read_climdata(mesoclim::ukcpinput)
hrsw <- swrad_dailytohourly(climdaily$swrad)
# Plot results for one cell
cell_sw<-t(extract(hrsw,matrix(c(175000,40000),ncol=2)))
matplot(as_datetime(time(hrsw)),cell_sw, type = "l", lty = 1)
# ========================================================================= #
# ~~~~~~~~~~~~~~~~~~~~ input provided as 3D array ======================= #
# ========================================================================= #
hrsw <- swrad_dailytohourly(.is(climdaily$swrad),tme=climdaily$tme,r=climdaily$dtm)
cell_sw<-hrsw[3,4,]
hr_tme<-as.POSIXlt(unlist(lapply(climdaily$tme,FUN=function(x) x+(60*60*c(0:23)) )))
matplot(x=as.numeric(hr_tme),y=cell_sw, type = "l", lty = 1)
# ========================================================================= #
# ~~~~~~~~~~~~~~~~~~~~ input provided as vector =========================== #
# ========================================================================= #
radsw <- c(120,150,100)
tme <- as.POSIXlt(c(0:2) * 3600 * 24, origin = "2018-05-01", tz = "UTC")
r=c(50,0) # (lat,lon of location)
hrsw <- swrad_dailytohourly(radsw,tme,r)
hr_tme<-as.POSIXlt(unlist(lapply(tme,FUN=function(x) x+(60*60*c(0:23)) )))
# Plot results to compare
matplot(x=as.numeric(hr_tme),y=hrsw, type = "l", lty = 1)

radsw<-unlist(global(climdaily$swrad,mean))
tme<-as.POSIXlt(terra::time(climdaily$swrad))
r<-c(50,-5)
hrsw <- swrad_dailytohourly(radsw,tme,r)
hr_tme<-as.POSIXlt(unlist(lapply(tme,FUN=function(x) x+(60*60*c(0:23)) )))
# Plot results to compare
matplot(x=as.numeric(hr_tme),y=hrsw, type = "l", lty = 1)
}
\keyword{temporal}
