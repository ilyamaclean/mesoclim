---
title: "spatial_downscaling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spatial_downscaling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

## devtools::build_rmd("C:/Users/jm622/OneDrive - University of Exeter/Rprojects/mesoclim/vignettes/spatial_downscaling.Rmd")
```

```{r setup, eval=FALSE}
library(mesoclim)
```

# Overview
The mesoclim package provides a range of functions to enable the mechanistic and statistical downscaling of climate data from coarse spatial (and sometime temporal resolutions) to resolutions at which mesoclimatic processes, such as the effects of elevation, cold air drainage, coastal exposure and other topographical shelter significantly affect how local climate and weather conditions vary across the landscape. The package will permit the downscaling of climate data with a spatial resolution of 10s of kilometers to resolutions of under a kilometer. It does not permit the modelling of microclimatic processes or of below-canopy or below-ground conditions, but provides suitable data for subsequent microclimate modelling (refs to other packages).

The functions address key steps and applications of the downscaling work flow, namely:

* __Downloading & preprocessing of coarse resolution global climate data describing historic or future climates.__ Functions allow the downloading of global gridded climate data at resolutions of 10s of kilometers at daily or hourly intervals and their processing to generate a standard inputs for the mesoclimate modelling functions. Functions are also provided to download ancillary data that can be required for downscaling, including digital elevation maps of areas of interest.

{_Something on using weather station inputs??_}

* __Spatial downscaling.__  Functions capture the effect of specific processes such as elevation, coastal exposure or cold air drainage, whereas wrapper functions apply the chosen processes to downscale climate conditions to finer resolutions. Available function allow a high degree of control of which mesoclimatic effects are used in downscaling the selection of which may reflec user focus and/or whether particular processes have been partially captured in the input datasets.

* __Temporal downscaling.__ Functions allow the conversion of daily to hourly estimates of climate conditions.

* __Bias correction.__ A series of functions are provided to statistically compare different climate datasets and correct one set of data against another. Typically these functions will be used to correct modelled data with observational data. MORE

Functions are also provided to carry out simple data checking, statistical summaries and graphing of climate datasets.


# Downloading  of coarse resolution global climate data.
A number of source-specific functions are provided for both the downscaling and processing of coarse-resolution climate data.Data sources include ERA5 Reanalysis data produced by the Copernicus Climate Change Service (ref), NCEP-NCAR and NCEP–DOE Atmospheric Model Intercomparison Project (Kanamitso et al 2002), and UKCP18 global and regional future climate estimates. {_Others: Worldclim??_}. 

## Example: downloading ERA5 reanalysis data for Cornwall, UK
```{r download_era5}


```


## Example: downloading UKCP18 regional data for Cornwall, UK
UKCP18 data is available at several different resolutions from various climate models that have been run to produce outputs for global, European and UK extents. 

Data requires a ceda username and password.

The function will download netcdf file(s) containing a decade of data that correspond to the model, collection, domain and time period requested. UKCP18 files contain a single variable and therefore multiple files will be downloaded

For further details see: {MetOff reference}

__TO DO:__ ADD download of UKCP18 rcm dem option to function and to ERA5 using geopotential!!!

```{r download_ukcp, eval=FALSE}
dir_ukcp18<-tempdir()
collection<-'land-rcm'
domain<-'uk'
member<-'01'
rcp<-'rcp85'
startdate<-as.POSIXlt('2018/01/01')
enddate<-as.POSIXlt('2018/12/31')

download_ukcp18(
    dir_ukcp18,
    cedausr,cedapwd,
    startdate,enddate,
    collection, domain, rcp, member,
    vars=c('clt','hurs','pr','prsn','psl','rls','rss','tasmax','tasmin','uas','vas')
)

list.files(dir_ukcp18)
```

## Ancillary data download
Where possible, the DTM should correspond to data used in the climate modelling. For example, this is made available for UKCP18 RCM data and can be derived from ERA5 using the geopotential variable. {An option in the corresponding functions allows the downloading of DTMs.}

for Where a DTM of the same geometry as the climate data is not available and provided by the download function, if can be derived from various webservices and resampled to the correct projetion and resolution.

```{r accillary-download, eval=FALSE}
# Get UKCP18 sea surface temp data

```

# Preprocessing coarse resolution climate data
## Defining area of interest
Unless we are wanting to analyse the whole area covered by downloaded climate data, it is best to define a broad area of interest to restrict data size and processing times. The area of interest is used to crop a coarse DTM of the same projection and resolution as the climate data to provide a template for data processing. 

```{r define_aoi}
dir_data<-system.file('data-raw',package='mesoclim')
#list.files(dir_data)
dtm<-terra::rast(file.path(dir_data,'orog_land-rcm_uk_12km_osgb.nc'))
aoi<-terra::vect(terra::ext(-7.125,-2.875,49.375,51.625),crs='EPSG:4326')
aoi_e<-terra::project(aoi,terra::crs(dtm))
dtm<-terra::crop(dtm,aoi_e)
plot(dtm,main='DTM of climate data extent to be extracted')
```

## Creation of standard inputs for downscaling
### UKCP18 preprocessing
UKCP18 data preprocessing requires the conversion of net to downward short and longwave radiation. The conversion of shortwave radiation is calculated using an estimate of albedo at the same resolution as the climate data. Albedo data can either be provided or when not, constant land/sea albedo values are used.

```{r preprocess, results="hide"}

# Preprocess UKCP18 data using constant albedo land / sea values
collection<-'land-rcm'
domain<-'uk'
member<-'01'
rcp<-'rcp85'
startdate<-as.POSIXlt('2018/01/01')
enddate<-as.POSIXlt('2018/12/31')

ukcp18rcm<-ukcp18toclimarray(dir_data, dtm,  startdate, enddate,
                             collection, domain, member)
```

### ERA5 preprocessing

### Sea Surface Temperature preprocessing
```{r sst-preprocess, eval=FALSE}
ukcp18sst<-create_ukcpsst_data('data-raw',startdate,enddate,aoi,member)
plot(ukcp18sst)
```

## Checking data inputs to downscaling
The resulting data structures of preprocessing can be checked to ensure there are no missing or unexpected values that may indicate a difference in the expected SI units or incomplete input datasets. This is particularly advisable if the inputs for spatial downscaling are not derived from one of the provided functions.

```{r check_inputs}
ukcp18rcm<-checkinputs(ukcp18rcm, tstep = "day")
```


# Spatial Downscaling
The projection, resolution and extent of the downscaled data is defined by a fine-resolution DTM

```{r downscaled-dtm,  results="hide"}
dir_datasets<-system.file('data',package='mesoclim')
load(file.path(dir_datasets,'dtmf.rda'))
load(file.path(dir_datasets,'dtmm.rda'))
load(file.path(dir_datasets,'ukcp18sst.rda'))

dtmm<-unwrap(dtmm)
dtmf<-unwrap(dtmf)
ukcp18sst<-unwrap(ukcp18sst)
```

## Single step downscaling
Wrapper functions allows downscaling in a single step.


```{r onestep-spdown}
# Interpolate SST data to required timesteps
sst<-spatial_interpNA(ukcp18sst)
sst<-time_interp(sst,ukcp18rcm$tme)

t0<-now()
mesolizd<-spatialdownscale(ukcp18rcm, sst, dtmf, dtmm, basins = NA, cad = TRUE,
                           coastal = TRUE, refhgt = ukcp18rcm$tempheight_m, uhgt = ukcp18rcm$windheight_m, 
                           rhmin = 20, pksealevel = TRUE, patchsim = TRUE, terrainshade = FALSE, 
                           precipmethod = "Tps", fast = TRUE, noraincut = 0.01)
print(now()-t0)

# saveRDS(file = 'C:/Users/jm622/OneDrive - University of Exeter/Rprojects/mesoclim_local/Test_datamesolizd.RDS', mesolizd)
```

Graphing of outputs
```{r analyse-outputs}

for(var in names(mesolizd)){
  print(var)
  r<-terra::unwrap(mesolizd[[var]])
  plot(contrast_layers(r),main=var)
}

```

## Multiple step downscaling

### Pressure - outputs as rast
```{r pressure_dscale}
mesoclim<-list()

mesoclim$pres<-presdownscale(ukcp18rcm$climarray$pres, dtmf, ukcp18rcm$dtmc, sealevel = TRUE)
plot(contrast_layers(mesoclim$pres))
```


### Cold air drainage -   CHECK for where basin boundary>0 - fails??
```{r calc_basins}
# Basins - dtmf should have sea marked by NA!
basins<-basindelin(dtmf,boundary=2)
plot(basins,main='basins')
```

```{r calc_cad}
# Calculate using tmin to illustrate
ukcp18rcm$climarray$temp<-ukcp18rcm$climarray$tmin
tcad<-.tempcad(ukcp18rcm,dtmf,basins,refhgt=ukcp18rcm$tempheight_m)
plot(contrast_layers(tcad,fun='min'), main='CAD effects')
```

### Temperature Elevation downscaling
```{r temp_elev_dscale}
tminelev<-.tempelev(ukcp18rcm$climarray$tmin,dtmf,ukcp18rcm$dtmc,ukcp18rcm$climarray$relhum,ukcp18rcm$climarray$pres)
tmaxelev<-.tempelev(ukcp18rcm$climarray$tmax,dtmf,ukcp18rcm$dtmc,ukcp18rcm$climarray$relhum,ukcp18rcm$climarray$pres)
plot(contrast_layers(tminelev),main='Tmin elev downscaled')
plot(contrast_layers(tmaxelev),main='Tmax elev downscaled')

```

### Wind
```{r wind_dscale}
mesoclim$windspeed<-winddownscale(ukcp18rcm$climarray$windspeed, ukcp18rcm$climarray$winddir, dtmf, dtmm, ukcp18rcm$dtmc, uz = ukcp18rcm$windheight_m)
#plot(contrast_layers(.rast(climdata$winddir,dtmc),p=c(0,0.25,0.5,0.75)))
plot(contrast_layers(mesoclim$windspeed),main='Downscaled windspeed')

#windplot(ukcp18rcm$climarray$winddir,as.array(mesoclim$windspeed))
```
### Coastal effects
```{r coastal}
# Coastal effect on temp
# Input temperature = downscaled temperature matching dtmf
# wind speed = result of winddownscale()
# wind dir reduced to single value for whole area
# sst = to match dtmf!!!
sstf<-.resample(sst,dtmf)
tmincoast<-.tempcoastal(tminelev,sstf,mesoclim$windspeed,ukcp18rcm$climarray$winddir,dtmf,dtmm,dtmc)
tmaxcoast<-.tempcoastal(tmaxelev,sstf,mesoclim$windspeed,ukcp18rcm$climarray$winddir,dtmf,dtmm,dtmc)

plot(contrast_layers(tmincoast),main='Coast effect of Tmin (elev)')
plot(contrast_layers(tmaxcoast),main='Coast effect of Tmax (elev)')

```
### All temperature effect downscaling
```{r temp-dscale}
ukcp18rcm$climarray$temp<-ukcp18rcm$climarray$tmin
mesoclim$tmin<-tempdownscale(
                  ukcp18rcm,
                  sst,# can be coarse
                  dtmf, # fine scale dem
                  dtmm , # medium re wider are dem
                  basins = basins, # basindelin() output
                  u2 = mesoclim$windspeed, # windspeeds downscaled
                  cad = TRUE,
                  coastal = TRUE,
                  refhgt = ukcp18rcm$tempheight_m, # temp height
                  uhgt = ukcp18rcm$windheight_m # wind height
                  )

ukcp18rcm$climarray$temp<-ukcp18rcm$climarray$tmax
mesoclim$tmax<-tempdownscale(
                  ukcp18rcm,
                  sst,# can be coarse
                  dtmf, # fine scale dem
                  dtmm , # medium re wider are dem
                  basins = basins, # basindelin() output
                  u2 = mesoclim$windspeed, # windspeeds downscaled
                  cad = TRUE,
                  coastal = TRUE,
                  refhgt = ukcp18rcm$tempheight_m, # temp height
                  uhgt = ukcp18rcm$windheight_m # wind height
                  )

plot(contrast_layers(mesoclim$tmin),main='Downscaled Tmin')
mtext(time(contrast_layers(mesoclim$tmin)))
plot(contrast_layers(mesoclim$tmax),main='Downscaled Tmax')


```

### Precipitation
```{r precip-dscale}
# Precipitation downscale - compare 'Elev' with 'Tps' methods,
precelev<-precipdownscale(
  ukcp18rcm$climarray$prec,
  dtmf,
  ukcp18rcm$dtmc,
  method = "Elev", # or "Elev"
  fast = TRUE,
  noraincut = 0.01,
  patchsim = FALSE,
  nsim = dim( ukcp18rcm$climarray$prec)[3]
)
prectps<-precipdownscale(
  ukcp18rcm$climarray$prec,
  dtmf,
  ukcp18rcm$dtmc,
  method = "Tps", # or "Elev"
  fast = TRUE,
  noraincut = 0.01,
  patchsim = FALSE,
  nsim = dim( ukcp18rcm$climarray$prec)[3]
)

plot(contrast_layers(precelev),main='Precipitation (elev method')
plot(contrast_layers(prectps),main='Precipitation (Tps method')

mesoclim$prec<-prectps
```
### SW radiation downscale
```{r sw-dscale}
mesoclim$swrad<-swdownscale(ukcp18rcm$climarray$swrad,as.POSIXlt(ukcp18rcm$tme, tz = "UTC"),dtmf,ukcp18rcm$dtmc)
                            #patchsim = FALSE,nsim= dim(swrad)[3],terrainshade = FALSE)
plot(contrast_layers(mesoclim$swrad))
```


 ...With terrain shading  & calculation of diffuse radiation - stil buggy!!
```{r sw-terraindscale, eval=FALSE}
rad<-swdownscale(ukcp18rcm$climarray$swrad,ukcp18rcm$tme,dtmf,ukcp18rcm$dtmc,terrainshade = TRUE)
swf<-rast(rad$swf)
drf<-rast(rad$drf)

plot(contrast_layers(swf),main= 'SW rad in W/m/s')
plot(contrast_layers(drf),main='diffuse fraction')
```

... with terrain shading and patchiness
```{r sw-trnpatchdscale, eval=FALSE}
rad<-swdownscale(ukcp18rcm$climarray$swrad,ukcp18rcm$tme,dtmf,ukcp18rcm$dtmc,patchsim = TRUE,nsim= dim(swrad)[3],terrainshade = TRUE)
swf<-rast(rad$swf)
drf<-rast(rad$drf)

plot(swf[[contrast_layers(swf)]],main= 'SW rad in W/m/s')
plot(drf[[contrast_layers(drf)]],main='diffuse fraction')
```


## Compare input data tp downscaled data

```{r compare_dscale}

for(v in names(mesolizd)){
  r<-unwrap(mesolizd[[v]])
  terra::time(r)<-ukcp18rcm$tme
  plot_timestats_r(r,v,idx='doy',lgd=FALSE)
}

```
```{r compare_inout, include=FALSE}
rw<-16
cl<- 13 
for(v in names(mesolizd)){
  print(v)
  r<-unwrap(mesolizd[[v]])
  terra::time(r)<-ukcp18rcm$tme
  if(v %in% names(ukcp18rcm$climarray)){
    tseries<-ukcp18rcm$climarray[[v]][rw,cl,] 
    plot_timecomp_r(r,tseries,v,idx='doy',lgd=FALSE)
  }
```

# Bias Correction
Compares modeled historic data with observational data.
Requires comparable raster stacks of observed and modeled data.

```{r get-obsdata}
dir_haduk<-'C:/Users/jm622/OneDrive - University of Exeter/Add_Trees/HadUK'
tminfiles<- list.files(dir_haduk, pattern='tasmin')
tmaxfiles<- list.files(dir_haduk, pattern='tasmax')
rainfiles<- list.files(dir_haduk, pattern='rainfall')
tminhuk<-rast(file.path(dir_haduk,tminfiles))
tmaxhuk<-rast(file.path(dir_haduk,tmaxfiles))
prechuk<-rast(file.path(dir_haduk,rainfiles))

# Crop
e<-ext(project(dtmf,crs(tminhuk)))
tminhuk<-crop(tminhuk,e)
tmaxhuk<-crop(tmaxhuk,e)
prechuk<-crop(prechuk,e)

```

Model data would normally be from downscaling to resolution of observed rather than aggregating as here.

```{r get-moddata}
tmin<-.resample(unwrap(mesolizd$tmin),tminhuk[[1]])
tmax<-.resample(unwrap(mesolizd$tmax),tminhuk[[1]])
prec<-.resample(unwrap(mesolizd$prec),tminhuk[[1]])

```


```{r bias-correct, include=FALSE}
# Get bias correction model
tmn_bmods<-biascorrect(tminhuk, tmin, tmin,mod_out = TRUE, rangelims = NA)
print(tmn_bmods$models)
mn_stats<-c(app(tminhuk/tmin,mean),app(tminhuk/tmin,sd),app(tminhuk/tmin,max))
cf_mins<- c(app(tminhuk,min),app(tmin,min)) 
names(cf_mins)<-c('Yr tmn HadUK Observed','Yr tmn UKCP18 downsscaled')
plot(cf_mins)

tmx_bmods<-biascorrect(tmaxhuk, tmin, tmin,mod_out = TRUE, rangelims = NA)
print(tmx_bmods$models)
cf_maxs<- c(app(tmaxhuk,max),app(tmax,max)) 
names(cf_maxs)<-c('Yr tmx HadUK Observed','Yr tmx UKCP18 downsscaled')
plot(cf_maxs)

mx_stats<-c(app(abs(tmaxhuk/tmax),mean),app(abs(tmaxhuk/tmax),sd),app(abs(tmaxhuk/tmax),max))
plot(mx_stats)



prec_bmods<-precipcorrect(prechuk, prec, prec, mod_out = TRUE, rangelim = NA)

plot(unwrap(prec_bmods$mu_tot),main='Total rainfall')
plot(unwrap(prec_bmods$mu_frac ),main='Proportion of rainy days')

```
# Apply bias corrections
```{r apply_bmods, include=FALSE}
fut_correct<-biascorrect_apply(fut_mod, biasmods, rangelims = NA)

futprec_correct<-precipcorrect_apply(fut_mod, precipmods)
```


# Changes and Bugs
Why do we have two level list for input data - do we need climarray??
Calculate (mean) temp  when preprocessing daily data? No 
Winbd downscale - output dir for each windspeed layer?
