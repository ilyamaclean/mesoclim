---
html_document:
  toc: true
  toc_float:
    collapsed: false
    smooth_scroll: false
  toc_depth: 2
title: "2. Spatial downscaling"
---

```{r, echo=FALSE,include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup, echo=FALSE, include=FALSE}
library(lubridate)
library(terra)
#library(mesoclim)
library(devtools)
load_all()
```


# Spatial Downscaling of regional climate data

## Data inputs

Coarse resolution climate and ancillary data (including sea surface temperature data where appropriate) will need to be prepared as outlined in `vignette('mesoclim_data_requirements', package='mesoclim')`.  

Here we load package data saved as .rda files using the ??? functions

```{r load_data}
# Must unpack spatrasters etc saved in .rda data object
ukcpinput<-read_climdata(mesoclim::ukcpinput)
ukcp18sst<-rast(mesoclim::ukcp18sst)
ukcpinput$dtm<-unwrap(ukcpinput$dtm)
```

## Defining the area of interest

The projection, resolution and extent of the downscaled area is defined by providing a fine-resolution DTM that also acts as a land/sea mask with sea cells identified as possessing a NA value.

```{r downscaled-dtm,  results="hide"}
# Get fine and medium res DTMs from package
dtmf<-rast(system.file("extdata/dtms/dtmf.tif",package="mesoclim"))
dtmm<-rast(system.file("extdata/dtms/dtmm.tif",package="mesoclim"))
dtmc<-ukcpinput$dtm
# Show local downscale area within wider dtmm
aoi<-vect(ext(dtmf))
plot.new()
plot(ukcpinput$dtm,main='Downscale area of interest within 1km dtmm and 12km ukcp18 dtm')
plot(dtmm, add=T)
plot(aoi,add=TRUE)
```

## Single step downscaling

Wrapper function allows downscaling in a single function call, with parameters defining which processes are captured by the downscaling.

```{r onestep-spdown}

# Downscale one year of future climate data

t0<-now()
wca<-calculate_windcoeffs(ukcpinput$dtm,dtmm,dtmf,zo=2)
basins<-basindelin(dtmf, boundary = 2)
  
mesoclimate<-spatialdownscale(climdata=ukcpinput, sst=ukcp18sst, dtmf, dtmm, basins = basins,  wca=wca, cad=TRUE,coastal = TRUE, thgto =2, whgto=2, rhmin = 20, pksealevel = FALSE, patchsim = TRUE,  terrainshade = TRUE, precipmethod = "Elev", fast = TRUE, noraincut = 0.01, toArrays=FALSE) # CHECK pksealevel
print(now()-t0)
names(mesoclimate)

# write_climdata(mesoclimate,file.path(system.file('data',package='mesoclim'),'mesoclimate.rda'),overwrite=TRUE)

# To write file:
# dir_tmp<-dir_temp()
# write_climdata(mesoclimate,file.path(dir_tmp,'mesoclimate.rds'))
# mesoclimate<-read_climdata(file.path(dir_tmp,'mesoclimate.rds')))

```

### Display outputs

In tabular form for all times and locations:

```{r output_table}
climvars<-c('tmin','tmax','relhum','pres','swrad','lwrad','windspeed','winddir','prec')
smry_fun<-function(x) summary(as.vector(as.array(x)))
rslt<-sapply(mesoclimate[climvars],smry_fun)
stats_df<-as.data.frame(t(round(rslt,3)))[,c('Min.','Mean','Max.')]
print(stats_df)
```

Or as selected rasters for days corresponding to spatial quantiles (ie days where spatial means across the area of interest are at their min, median and max values):

```{r map-outputs, message=FALSE, warning=FALSE}
p=c(0, 0.5, 1)
par(mfrow=c(1,3), mai=c(1,0.1,0.1,0.1))
  for(var in climvars){
    r<-mesoclimate[[var]]
    lyrstat<-global(r,mean,na.rm=TRUE)
    qtls<-quantile(lyrstat[,1],prob=p)
    sel<-c()
    for(q in qtls) sel<-c(sel,which.min(abs(lyrstat[,1] - q)))
    out_r<-r[[sel]]
    names(out_r)<-paste(var,terra::time(r[[sel]]))
    plot(out_r,main=names(out_r),font.main=1, cex.main=1, nc=length(p))
  }

# Show spatial range in daily temperatures
plot(max(mesoclimate$tmax)-min(mesoclimate$tmin),main='Max diurnal temperature range', font.main = 1, nc=1)
```

Or plot how climate variables vary spatially and with time. Here downscaled mean/max and min for the area of interest are plotted across the timeseries.

```{r tseries_output}
par(mar=c(1,1,1,1),cex.main=0.8, mgp=c(3,0.1,0))
layout(matrix(c(1,2,3,4,1,5,6,7,1,8,9,10),ncol=3),heights=c(1,3,3,3))
plot.new()
text(0.5,0.5,"Spatial mean (green), max (red) and min (blue) by day of year",cex=1,font=1)
idx<-'doy'
for(v in climvars){
  r<-mesoclimate[[v]]
  time_mean<-tapp(r,index=idx,fun=mean) %>% global("mean", na.rm=TRUE)
  time_max<-tapp(r,index=idx,fun=max) %>% global("max", na.rm=TRUE)
  time_min<-tapp(r,index=idx,fun=min) %>% global("min", na.rm=TRUE)
  plot_df<-as.data.frame(cbind(tstep=as.numeric(sapply(strsplit(rownames(time_mean),'_'),tail,1)),mean=time_mean$mean,max=time_max$max,min=time_min$min))
  plot_df<-plot_df[order(plot_df$tstep),]
  matplot(as_datetime(plot_df$tstep), plot_df[,2:4], type = "l", lty = 1,
          col = c("green", "red", "blue"), xlab = idx, ylab = v, font.main = 1,
          tck = 0.02, cex.main=1, cex.axis=0.7, main = paste(v,'by',idx), cex.main=1)
  legend("topright", legend = c("Mean", "Max", "Min"), cex=0.5,
         col = c("green", "red", "blue"),
         lty = 1)
}

```


## Multiple step downscaling

Spatial downscaling can be decomposed to the effects of specific physical processes, such as the effect of elevation, coastal or cold air drainage on temperature. Specific functions for downscaling particular effects can be applied without needing to undertake full downscaling using all processes.

_Note:_ for individual functions, outputs may need further processing to ensure names are times are carried through.

### Possible Improvements
* Allow option of spatrast or array outputs for all functions? Or enforce a standard spatrast output?
* Allow passing standard data input list of climdata as well as individual variables?
* Allow variable winddir in windspeed downscaling - or warning message if input wind dir varies?

### Pressure 

Currently outputs as raster.

```{r pressure_dscale}
pres<-presdownscale(ukcpinput$pres, dtmf, ukcpinput$dtm, sealevel = TRUE)
names(pres)<-rep('pres',nlyr(pres))
terra::time(pres)<-ukcpinput$tme
plot(pres[[13]],main=paste("Pressue",time(pres[[13]])))
```


### Cold air drainage 

Requires the estimation of drainage basins defined by topography which can be carried out separately from the estimation of cold-air drainage in downscaling.

```{r calc_basins}
# Basins - dtmf should have sea marked as NA
basins<-basindelin(dtmf,boundary=2)
plot(basins,main='basins')
```

For the chosen study area, cold air drainage has no effect on local temperatures during the chosen timeperiod (May):

```{r calc_cad}
# Calculate using tmin to illustrate
ukcpinput$temp<-ukcpinput$tmin
tcad<-.tempcad(ukcpinput,dtmf,basins,refhgt=ukcpinput$tempheight_m)

names(tcad)<-rep('temp_cad',nlyr(tcad))
terra::time(tcad)<-ukcpinput$tme
plot(tcad[[19]],main=paste("Cold air drainage",time(pres[[13]])))
```

### Temperature elevation downscaling

Variable lapse rates derived from temperature, humidity and pressure are applied to correct for elevation effects when downscaling. For daily  temperatures this can be carried out for min and max daily values.
```{r temp_elev_dscale}
tminelev<-.tempelev(ukcpinput$tmin,dtmf,ukcpinput$dtm,ukcpinput$relhum,ukcpinput$pres)
tmaxelev<-.tempelev(ukcpinput$tmax,dtmf,ukcpinput$dtm,ukcpinput$relhum,ukcpinput$pres)

names(tminelev)<-rep('tmin_elev',nlyr(tminelev))
terra::time(tminelev)<-ukcpinput$tme

names(tmaxelev)<-rep('tmax_elev',nlyr(tmaxelev))
terra::time(tmaxelev)<-ukcpinput$tme

# Check dirunal range of elev downscaling
diurnaltmp<-tmaxelev-tminelev
names(diurnaltmp)<-rep('diurnal_t_range',nlyr(diurnaltmp))

par(mfrow=c(1,3), mai=c(1,0.1,0.1,0.1))
plot(c(tminelev[[13]],tmaxelev[[13]],diurnaltmp[[13]]))

```

### Wind

Windspeed downscaling aims to capture the effect of both elevation and the sheltering effects of topography that are in turn dependent on wind direction and height above ground. 

```{r wind_dscale}
windspeed<-winddownscale(ukcpinput$windspeed, ukcpinput$winddir, dtmf, dtmm, ukcpinput$dtm, zi = ukcpinput$windheight_m, zo=2)

names(windspeed)<-rep('windspeed',nlyr(windspeed))
terra::time(windspeed)<-ukcpinput$tme

plot(windspeed[[13]])

```

### Coastal effects

Uses sea surface temperatures, DTMs where sea is indicated by NA values and downscaled windspeed to estimate the effect of coastal effects.
Coarse, medium and fine resolution DTMs are used to determine effects of upwind sea areas.

_ADD:_ Guidance on selection of the extent of dtmm - how far should dtms extend from the downscaling area to adequately capture coastal effects??

```{r coastal}
# Interpolate - filling NAs and ensuring timesteps match climate inputs - NOT REQUIRED AND FORGETS ABOUT LAND CELLS=NA!!!!
if (any(global(ukcp18sst,anyNA))) sstinterp<-.spatinterp(ukcp18sst) else sstinterp<-ukcp18sst
sstinterp<-.tmeinterp(sstinterp,NA,ukcpinput$tme)
# Resample to dtmf
if (crs(sstinterp) != crs(dtmf)) sstinterp<-project(sstinterp,crs(dtmf))
sstf<-.resample(sstinterp,dtmf)

# Calculate coastal temp effects - uses already downscaled windspeed
tmincoast<-.tempcoastal(tminelev,sstf,windspeed,ukcpinput$winddir,dtmf,dtmm,ukcpinput$dtm)
tmaxcoast<-.tempcoastal(tmaxelev,sstf,windspeed,ukcpinput$winddir,dtmf,dtmm,ukcpinput$dtm)

names(tmincoast)<-rep('tmin_coastef',nlyr(tmincoast))
terra::time(tmincoast)<-ukcpinput$tme
names(tmaxcoast)<-rep('tmax_coastef',nlyr(tmaxcoast))
terra::time(tmaxcoast)<-ukcpinput$tme

plot(c(tmincoast[[13]],tmaxcoast[[13]]))
```

### All temperature effects downscaling

If only concerned with temperature downscaling, the wrapper function `tempdownscale` allows all relevant processes to be run as a single function. 
```{r temp-dscale}
tmin<-tempdownscale( ukcpinput,
                  ukcp18sst,# can be coarse resolution
                  dtmf, # fine scale dem
                  dtmm , # medium re wider are dem
                  basins = basins, # basindelin() output or will calculate
                  u2 = windspeed, # windspeeds downscaled - or will calculate
                  cad = TRUE,
                  coastal = TRUE,
                  tempvar = 'tmin',
                  whgto = 2, # output wind height above ground
                  thgto = 2 # output temperature height above ground
                  )

tmax<-tempdownscale(ukcpinput,
                  ukcp18sst,# can be coarse
                  dtmf, # fine scale dem
                  dtmm , # medium re wider are dem
                  basins = basins, # basindelin() output
                  u2 = windspeed, # windspeeds downscaled
                  cad = TRUE,
                  coastal = TRUE,
                  tempvar = 'tmax',
                  whgto = 2, # output wind height above ground
                  thgto = 2 # output temperature height above ground
                  )

# Dirunal range
diurnaltmp<-tmax-tmin
names(diurnaltmp)<-rep('Diurnal_temp_range',nlyr(diurnaltmp))

plot(c(tmin[[13]],tmax[[13]],diurnaltmp[[13]]),main=paste(c("Tmin","Tmax","Diurnal range"),"13/05/2018"))

```

### Precipitation

The `precipdownscale()` function provides various options and methods to downscale rainfall. 


```{r precip-dscale}
method<-'Elev'
precelev<-precipdownscale(
  ukcpinput$prec,
  dtmf,
  ukcpinput$dtm,
  method = method,
  fast = TRUE,
  noraincut = 0.01,
  patchsim = FALSE,
  nsim = dim( ukcpinput$prec)[3]
)
names(precelev)<-rep('prec_elev',nlyr(precelev))
terra::time(precelev)<-ukcpinput$tme

method<-'Tps'
prectps<-precipdownscale(
  ukcpinput$prec,
  dtmf,
  ukcpinput$dtm,
  method = method,
  fast = TRUE,
  noraincut = 0.01,
  patchsim = FALSE,
  nsim = dim( ukcpinput$prec)[3]
)
names(prectps)<-rep('prec_tps',nlyr(prectps))
terra::time(prectps)<-ukcpinput$tme

doy<-15
plot(c(precelev[[doy]],prectps[[doy]],precelev[[doy]]-prectps[[doy]]),main=paste(c("Elevation method","Tps method","Difference"),"01/05/2018"))

prec<-prectps
```

### Longwave radiation downscale

Longwave downscaling accounts for the effects of terrain shading effect on skyview.
```{r lw-dscale}
# simple downscaling
lwf<-.resample(.rast(ukcpinput$lwrad,ukcpinput$dtm), dtmf, msk=TRUE)
# corrected for skyview  
svf<-.rta(.skyview(dtmf),dim(lwf)[3])
lwrad<-.rast(as.array(lwf)*svf,dtmf)

names(lwrad)<-rep('lwrad',nlyr(lwrad))
terra::time(lwrad)<-ukcpinput$tme
plot(lwrad[[13]],main="LW radiation 13/05/2018")

```

### Shortwave radiation downscale

Options include downscaling with effects of terrain shading and / or a simulation of cloud patchiness.
```{r sw-dscale}
swrad_noef<-swdownscale(ukcpinput$swrad,as.POSIXlt(ukcpinput$tme, tz = "UTC"),dtmf,ukcpinput$dtm,patchsim = FALSE,terrainshade = FALSE)
swrad_tshd<-swdownscale(ukcpinput$swrad,as.POSIXlt(ukcpinput$tme, tz = "UTC"),dtmf,ukcpinput$dtm,patchsim = FALSE,terrainshade = TRUE)
swrad_cldtshd<-swdownscale(ukcpinput$swrad,as.POSIXlt(ukcpinput$tme, tz = "UTC"),dtmf,ukcpinput$dtm,patchsim = TRUE,terrainshade = TRUE)

swrad_compare<-c(swrad_noef$swf[[13]],swrad_tshd$swf[[13]],swrad_cldtshd$swf[[13]])
names(swrad_compare)<-c("SW no effect","SW terrainshade","SW terrainshade & patchsim")                      
plot(swrad_compare)
```


